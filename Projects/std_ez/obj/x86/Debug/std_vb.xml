<?xml version="1.0"?>
<doc>
<assembly>
<name>
std_vb
</name>
</assembly>
<members>
<member name="M:OldW.DllActivator.IDllActivator.ActivateReferences">
	<summary> 激活本DLL所引用的那些DLLs </summary>
</member><member name="T:OldW.DllActivator.IDllActivator">
	<summary>
 用于在打开非模态窗口的的IExternalCommand.Execute方法中，
 </summary>
</member><member name="M:OldW.DllActivator.DllActivator_std_vb.ActivateReferences">
	<summary>
 激活本DLL所引用的那些DLLs
 </summary>
</member><member name="T:OldW.DllActivator.DllActivator_std_vb">
	<summary>
	</summary>
</member><member name="M:std_ez.eZDataGridView.myDataGridView_RowsNumberChanged(System.Object,System.Object)">
	<summary>
 行数改变时的事件：显示行号
 </summary>
	<param name="sender"></param>
	<param name="e"></param>
	<remarks></remarks>
</member><member name="M:std_ez.eZDataGridView.RowsResizable(System.Object,System.Windows.Forms.DataGridViewRowsAddedEventArgs)">
	<summary>
 设置新添加的一行的Resizable属性为False
 </summary>
	<param name="sender"></param>
	<param name="e"></param>
	<remarks></remarks>
</member><member name="M:std_ez.eZDataGridView.InsertRow(System.Object,System.EventArgs)">
	<summary>
 插入一行
 </summary>
	<param name="sender"></param>
	<param name="e"></param>
	<remarks></remarks>
</member><member name="M:std_ez.eZDataGridView.RemoveRow(System.Object,System.EventArgs)">
	<summary>
 移除一行
 </summary>
	<param name="sender"></param>
	<param name="e"></param>
	<remarks></remarks>
</member><member name="M:std_ez.eZDataGridView.ToolStripMenuItemRemoveRows_Click(System.Object,System.EventArgs)">
	<summary>
 移除多行
 </summary>
	<param name="sender"></param>
	<param name="e"></param>
	<remarks></remarks>
</member><member name="M:std_ez.eZDataGridView.myDataGridView_KeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
	<summary>
 如下按下Ctrl+V，则将表格中的数据粘贴到DataGridView控件中
 </summary>
	<remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
 DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。</remarks>
</member><member name="M:std_ez.eZDataGridView.PasteFromTable(System.Int32,System.Int32)">
	<summary> 将表格中的数据粘贴到DataGridView控件中 </summary>
	<param name="startRow">粘贴的起始单元格的行位置</param>
	<param name="startCol">粘贴的起始单元格的列位置</param>
	<remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
 DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。总行数包括最后一行空数据行。</remarks>
</member><member name="T:std_ez.eZDataGridView">
	<summary>
 自定义控件：DataGridView，向其中增加了：插入行、删除行、显示行号等功能
 </summary>
	<remarks></remarks>
</member><member name="F:std_ez.LstbxDisplayAndItem.DisplayMember">
	<summary>
 在列表框中进行显示的文本
 </summary>
	<remarks>此常数的值代表此类中代表要在列表框中显示的文本的属性名，即"DisplayedText"</remarks>
</member><member name="F:std_ez.LstbxDisplayAndItem.ValueMember">
	<summary>
 列表框中每一项对应的值（任何类型的值）
 </summary>
	<remarks>此常数的值代表此类中代表列表框中的每一项绑定的数据的属性名，即"Value"</remarks>
</member><member name="M:std_ez.LstbxDisplayAndItem.#ctor(System.String,System.Object)">
	<summary>
 构造函数
 </summary>
	<param name="DisplayedText">用来显示在列表的UI界面中的文本</param>
	<param name="Value">列表项对应的值</param>
	<remarks></remarks>
</member><member name="F:std_ez.LstbxDisplayAndItem.NothingInListBox.None">
	<summary>
 什么也没有选择
 </summary>
	<remarks></remarks>
</member><member name="T:std_ez.LstbxDisplayAndItem.NothingInListBox">
	<summary>
 列表框中用来表示“什么也没有”。
 1、在声明时：listControl控件.Items.Add(New LstbxDisplayAndItem(" 无", NothingInListBox.None))
 2、在选择列表项时：listControl控件.SelectedValue = NothingInListBox.None
 3、在读取列表中的数据时，作出判断：If Not LstbxItem.Value.Equals(NothingInListBox.None) Then ...
 </summary>
	<remarks></remarks>
</member><member name="T:std_ez.LstbxDisplayAndItem">
	<summary>
 用来作为ListControl类的.Add方法中的Item参数的类。通过指定ListControl类的DisplayMember属性，来设置列表框中显示的文本。 
 </summary>
	<remarks>
 保存数据时：
  With ListBoxWorksheetsName
       .DisplayMember = LstbxDisplayAndItem.DisplayMember
       .ValueMember = LstbxDisplayAndItem.ValueMember
       .DataSource = arrSheetsName   '  Dim arrSheetsName(0 To sheetsCount - 1) As LstbxDisplayAndItem
  End With
 提取数据时：
  Try
      Me.F_shtMonitorData = DirectCast(Me.ListBoxWorksheetsName.SelectedValue, Worksheet)
  Catch ex As Exception
      Me.F_shtMonitorData = Nothing
  End Try
 或者是：
  Dim lst As LstbxDisplayAndItem = Me.ComboBoxOpenedWorkbook.SelectedItem
  Try
     Dim Wkbk As Workbook = DirectCast(lst.Value, Workbook)
  Catch ex ...
 </remarks>
</member><member name="P:My.Resources.Resources.ResourceManager">
	<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member><member name="P:My.Resources.Resources.Culture">
	<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member><member name="T:My.Resources.Resources">
	<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member><member name="M:std_ez.Utils.ShowEnumerable(System.Collections.IEnumerable,System.String)">
	<summary>
 将集合中的每一个元素的ToString函数的结果组合到一个字符串中进行显示
 </summary>
	<param name="V"></param>
	<remarks></remarks>
</member><member name="M:std_ez.Utils.String2Date(System.String,System.DateTime@)">
	<summary>
 将字符转换为日期。除了.NET能够识别的日期格式外，
 还增加了20160406（ 即 2016/04/06），以及 201604061330（即 2016/04/06 13:30）
 </summary>
	<param name="text">要转换为日期的字符。</param>
	<returns></returns>
</member><member name="M:std_ez.Utils.SetDllDirectory(System.String)">
	<summary>
 将指定的文件夹添加到此程序的DLL文件的搜索路径中。
 这个函数只用来在开发时用于AddinManager调试之用，在最终的Release版本中，此函数中的内容可以直接删除。
 </summary>
	<param name="SearchPath">要添加的文件夹路径</param>
	<remarks></remarks>
</member><member name="M:std_ez.Utils.SetDllDirectoryW(System.String)">
	<summary>
 将指定的文件夹添加到此程序的DLL文件的搜索路径中.
 adds a directory to the search path used to locate DLLs for the application.
 </summary>
	<param name="lpPathName">要添加的文件夹路径</param>
	<remarks>Pretty straight-forward to use. Obviously, is usually going to be called before calling LoadLibraryEx().
 另外,在PInvoke中,只有SetDllDirectory这个函数,但是它的真实的名称是SetDllDirectoryW.</remarks>
</member><member name="M:std_ez.Utils.LoadLibraryEx(System.String,System.IntPtr,std_ez.Utils.LoadLibraryFlags)">
	<summary>
 装载指定的动态链接库，并为当前进程把它映射到地址空间。一旦载入，就可以访问库内保存的资源。一旦不需要，用FreeLibrary函数释放DLL
 </summary>
	<param name="lpFileName">指定要载入的动态链接库的名称。采用与CreateProcess函数的lpCommandLine参数指定的同样的搜索顺序</param>
	<param name="hReservedNull">未用，设为零</param>
	<param name="dwFlags"></param>
	<returns>成功则返回库模块的句柄，零表示失败。会设置GetLastError</returns>
	<remarks>参考 http://www.pinvoke.net/default.aspx/kernel32/LoadLibraryEx.html .
 If you only want to load resources from the library, specify LoadLibraryFlags.LoadLibraryAsDatafile as dwFlags. 
 In this case, nothing is done to execute or prepare to execute the mapped file.</remarks>
</member><member name="F:std_ez.Utils.LoadLibraryFlags.DONT_RESOLVE_DLL_REFERENCES">
	<summary> 不对DLL进行初始化，仅用于NT </summary>
</member><member name="F:std_ez.Utils.LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE">
	<summary> 不准备DLL执行。如装载一个DLL只是为了访问它的资源，就可以改善一部分性能 </summary>
</member><member name="F:std_ez.Utils.LoadLibraryFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
	<summary> 指定搜索的路径 </summary>
</member><member name="T:std_ez.Utils.LoadLibraryFlags">
	<summary>
 用在 LoadLibraryEx 函数中
 </summary>
	<remarks></remarks>
</member><member name="T:std_ez.Utils">
	<summary>
 提供一些基础性的操作工具
 </summary>
	<remarks></remarks>
</member><member name="P:std_ez.OwnerWindow.Handle">
	<summary> 父窗口的句柄值 </summary>
</member><member name="M:std_ez.OwnerWindow.#ctor(System.IntPtr)">
	<param name="Handle">作为父窗体的窗口句柄值</param>
	<remarks></remarks>
</member><member name="M:std_ez.OwnerWindow.CreateFromProcessName(System.String)">
	<summary> 通过当前运行的进程名称来获得对应的主窗体 </summary>
	<param name="ProcessName">当前运行的进程名称，此名称可以通过“Windows任务管理器 -&gt; 进程”进行查看。</param>
</member><member name="T:std_ez.OwnerWindow">
	<summary> 将任意一个窗体作为Form的父窗口 </summary>
</member><member name="M:std_ez.StringSerializer.Encode64(System.Object)">
	<summary>
 Encode arbitrary .NET serialisable object 
 into binary data encodes as base64 string.
 </summary>
</member><member name="M:std_ez.StringSerializer.Decode64(System.String)">
	<summary>
 Decode arbitrary .NET serialisable object 
 from binary data encoded as base64 string.
 </summary>
</member><member name="T:std_ez.StringSerializer.ZengfyLinkBinder">
	<summary>
 为了解决SerializationException，方法之一是确保此assembly放置在与acad.exe 或 revit.exe相同的文件夹中，
 另一个方法就是实现一个像这样的类。
 </summary>
	<remarks>
  Resolve System.Runtime.Serialization.SerializationException, Message = 
 "Unable to find assembly 'StoreData, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'."
 One solution is to ensure that assembly resides in same directory as acad.exe or revit.exe,
 the other is to implement a class such as this, cf. 
 http://www.codeproject.com/soap/Serialization_Samples.asp
 </remarks>
</member><member name="T:std_ez.StringSerializer">
	<summary>
 将任意一个有 Serializable标记的类以二进制转换器将类中所有数据与字符串间的相互序列化。
 即可以将类中的数据（包括数组）序列化为字符，还可以将序列化的字符反序列化为一个类。
 </summary>
</member><member name="M:std_ez.BinarySerializer.EnCode(System.IO.Stream,System.Object)">
	<summary>
 将任意一个声明为Serializable的类或者其List等集合中的数据，以二进制的格式保存到对应的流文件中。
 </summary>
	<param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
	<param name="Data">要进行保存的可序列化对象</param>
	<remarks></remarks>
</member><member name="M:std_ez.BinarySerializer.DeCode(System.IO.Stream)">
	<summary>
 从二进制流文件中，将其中的二进制数据反序列化为对应的类或集合对象。
 </summary>
	<param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
	<returns>此二进制流文件所对应的可序列化对象</returns>
	<remarks></remarks>
</member><member name="T:std_ez.BinarySerializer">
	<summary>
 在.NET中，我们可以将对象序列化从而保存对象的状态到内存或者磁盘文件中，或者分布式应用程序中用于系统通信，，这样就有可能做出一个“对象数据库”了。
 一般来说，二进制序列化的效率要高，所获得的字节数最小。
 </summary>
	<remarks></remarks>
</member>
</members>
</doc>