<?xml version="1.0"?>
<doc>
    <assembly>
        <name>std</name>
    </assembly>
    <members>
        <member name="M:std_zw.ExtensionMethods.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds range of items into collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items"></param>
        </member>
        <member name="M:std_zw.ExtensionMethods.ClearAndAddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Clears collection and adds range of items into it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items"></param>
        </member>
        <member name="M:std_zw.ExtensionMethods.Clone``1(``0)">
            <summary>
            Strong-typed object cloning for objects that implement <see cref="T:System.ICloneable"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:OldW.DllActivator.IDllActivator">
            <summary>
            用于在IExternalCommand.Execute方法中，将整个项目的所有dll加载到进程中。
            以避免出现在后面出现无法加载文件或者程序集的问题。
            此接口是专门为AddinManager在调试时设计的，在最终软件发布之前，此接口以及所有与之相关的类以及调用方法都可以删除。
            </summary>
            <remarks>在每一次调用Execute方法的开关，都可以用如下代码来将对应项目的所有引用激活。
            DllActivator.DllActivator_Projects dat = new DllActivator.DllActivator_Projects();
            dat.ActivateReferences();
            </remarks>
        </member>
        <member name="M:OldW.DllActivator.IDllActivator.ActivateReferences">
            <summary> 激活本DLL所引用的那些DLLs </summary>
        </member>
        <member name="T:OldW.DllActivator.DllActivator_std">
            <summary> </summary>
        </member>
        <member name="M:OldW.DllActivator.DllActivator_std.ActivateReferences">
            <summary>
            激活本DLL所引用的那些DLLs
            </summary>
        </member>
        <member name="T:std_ez.eZDataGridView">
            <summary>
            自定义控件：DataGridView，向其中增加了：插入行、删除行、显示行号等功能
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.myDataGridView_RowsNumberChanged(System.Object,System.Object)">
            <summary>
            行数改变时的事件：显示行号
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.RowsResizable(System.Object,System.Windows.Forms.DataGridViewRowsAddedEventArgs)">
            <summary>
            设置新添加的一行的Resizable属性为False
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.InsertRow(System.Object,System.EventArgs)">
            <summary>
            插入一行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.RemoveRow(System.Object,System.EventArgs)">
            <summary>
            移除一行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.ToolStripMenuItemRemoveRows_Click(System.Object,System.EventArgs)">
            <summary>
            移除多行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.myDataGridView_KeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            如下按下Ctrl+V，则将表格中的数据粘贴到DataGridView控件中
            </summary>
            <remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
            DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。</remarks>
        </member>
        <member name="M:std_ez.eZDataGridView.PasteFromTable(System.Int32,System.Int32)">
            <summary> 将表格中的数据粘贴到DataGridView控件中 </summary>
            <param name="startRow">粘贴的起始单元格的行位置</param>
            <param name="startCol">粘贴的起始单元格的列位置</param>
            <remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
            DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。总行数包括最后一行空数据行。</remarks>
        </member>
        <member name="T:std_ez.LstbxDisplayAndItem123">
            <summary>
            用来作为ListControl类的.Add方法中的Item参数的类。通过指定ListControl类的DisplayMember属性，来设置列表框中显示的文本。
            </summary>
            <remarks>
            保存数据时：
             With ListBoxWorksheetsName
                  .DisplayMember = LstbxDisplayAndItem.DisplayMember
                  .ValueMember = LstbxDisplayAndItem.ValueMember
                  .DataSource = arrSheetsName   '  Dim arrSheetsName(0 To sheetsCount - 1) As LstbxDisplayAndItem
             End With
            提取数据时：
             Try
                 Me.F_shtMonitorData = DirectCast(Me.ListBoxWorksheetsName.SelectedValue, Worksheet)
             Catch ex As Exception
                 Me.F_shtMonitorData = Nothing
             End Try
            或者是：
             Dim lst As LstbxDisplayAndItem = Me.ComboBoxOpenedWorkbook.SelectedItem
             Try
                Dim Wkbk As Workbook = DirectCast(lst.Value, Workbook)
             Catch ex ...
            </remarks>
        </member>
        <member name="F:std_ez.LstbxDisplayAndItem123.DisplayMember">
            <summary>
            在列表框中进行显示的文本
            </summary>
            <remarks>此常数的值代表此类中代表要在列表框中显示的文本的属性名，即"DisplayedText"</remarks>
        </member>
        <member name="F:std_ez.LstbxDisplayAndItem123.ValueMember">
            <summary>
            列表框中每一项对应的值（任何类型的值）
            </summary>
            <remarks>此常数的值代表此类中代表列表框中的每一项绑定的数据的属性名，即"Value"</remarks>
        </member>
        <member name="M:std_ez.LstbxDisplayAndItem123.#ctor(System.String,System.Object)">
            <summary>
            构造函数
            </summary>
            <param name="DisplayedText">用来显示在列表的UI界面中的文本</param>
            <param name="Value">列表项对应的值</param>
            <remarks></remarks>
        </member>
        <member name="T:std_ez.LstbxDisplayAndItem123.NothingInListBox">
            <summary>
            列表框中用来表示“什么也没有”。
            1、在声明时：listControl控件.Items.Add(New LstbxDisplayAndItem(" 无", NothingInListBox.None))
            2、在选择列表项时：listControl控件.SelectedValue = NothingInListBox.None
            3、在读取列表中的数据时，作出判断：If Not LstbxItem.Value.Equals(NothingInListBox.None) Then ...
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:std_ez.LstbxDisplayAndItem123.NothingInListBox.None">
            <summary>
            什么也没有选择
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:std_ez.LstbxValue`1">
            <summary>
            用来作为ListControl类的.Add方法中的Item参数的类。通过指定ListControl类的DisplayMember属性，来设置列表框中显示的文本。
            </summary>
            <remarks>
            保存数据时：
             With ListBoxWorksheetsName
                  .DisplayMember = LstbxDisplayAndItem.DisplayMember
                  .ValueMember = LstbxDisplayAndItem.ValueMember
                  .DataSource = arrSheetsName   '  Dim arrSheetsName(0 To sheetsCount - 1) As LstbxDisplayAndItem
             End With
            提取数据时：
             Try
                 Me.F_shtMonitorData = DirectCast(Me.ListBoxWorksheetsName.SelectedValue, Worksheet)
             Catch ex As Exception
                 Me.F_shtMonitorData = Nothing
             End Try
            或者是：
             Dim lst As LstbxDisplayAndItem = Me.ComboBoxOpenedWorkbook.SelectedItem
             Try
                Dim Wkbk As Workbook = DirectCast(lst.Value, Workbook)
             Catch ex ...
            </remarks>
            <typeparam name="Tval">Value属性所对应的类型</typeparam>
        </member>
        <member name="F:std_ez.LstbxValue`1.DisplayMember">
            <summary>
            在列表框中进行显示的文本
            </summary>
            <remarks>此常数的值代表此类中代表要在列表框中显示的文本的属性名，即"DisplayedText"</remarks>
        </member>
        <member name="F:std_ez.LstbxValue`1.ValueMember">
            <summary>
            列表框中每一项对应的值（任何类型的值）
            </summary>
            <remarks>此常数的值代表此类中代表列表框中的每一项绑定的数据的属性名，即"Value"</remarks>
        </member>
        <member name="M:std_ez.LstbxValue`1.#ctor(System.String,`0)">
            <summary>
            构造函数
            </summary>
            <param name="DisplayedText">用来显示在列表的UI界面中的文本</param>
            <param name="Value">列表项对应的值</param>
            <remarks></remarks>
        </member>
        <member name="T:std_ez.LstbxValue`1.NothingInListBox">
            <summary>
            列表框中用来表示“什么也没有”。
            1、在声明时：listControl控件.Items.Add(New LstbxDisplayAndItem(" 无", NothingInListBox.None))
            2、在选择列表项时：listControl控件.SelectedValue = NothingInListBox.None
            3、在读取列表中的数据时，作出判断：If Not LstbxItem.Value.Equals(NothingInListBox.None) Then ...
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:std_ez.LstbxValue`1.NothingInListBox.None">
            <summary>
            什么也没有选择
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:std_ez.StringSerializer">
            <summary>
            将任意一个有 Serializable标记的类以二进制转换器将类中所有数据与字符串间的相互序列化。
            即可以将类中的数据（包括数组）序列化为字符，还可以将序列化的字符反序列化为一个类。
            </summary>
        </member>
        <member name="M:std_ez.StringSerializer.Encode64(System.Object)">
            <summary>
            Encode arbitrary .NET serialisable object
            into binary data encodes as base64 string.
            </summary>
        </member>
        <member name="M:std_ez.StringSerializer.Decode64(System.String)">
            <summary>
            Decode arbitrary .NET serialisable object
            from binary data encoded as base64 string.
            </summary>
        </member>
        <member name="T:std_ez.StringSerializer.ZengfyLinkBinder">
            <summary>
            为了解决SerializationException，方法之一是确保此assembly放置在与acad.exe 或 revit.exe相同的文件夹中，
            另一个方法就是实现一个像这样的类。
            </summary>
            <remarks>
             Resolve System.Runtime.Serialization.SerializationException, Message =
            "Unable to find assembly 'StoreData, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'."
            One solution is to ensure that assembly resides in same directory as acad.exe or revit.exe,
            the other is to implement a class such as this, cf.
            http://www.codeproject.com/soap/Serialization_Samples.asp
            </remarks>
        </member>
        <member name="T:std_ez.BinarySerializer">
            <summary>
            在.NET中，我们可以将对象序列化从而保存对象的状态到内存或者磁盘文件中，或者分布式应用程序中用于系统通信，，这样就有可能做出一个“对象数据库”了。
            一般来说，二进制序列化的效率要高，所获得的字节数最小。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.BinarySerializer.EnCode(System.IO.Stream,System.Object)">
            <summary>
            将任意一个声明为Serializable的类或者其List等集合中的数据，以二进制的格式保存到对应的流文件中。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <param name="Data">要进行保存的可序列化对象</param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.BinarySerializer.DeCode(System.IO.Stream)">
            <summary>
            从二进制流文件中，将其中的二进制数据反序列化为对应的类或集合对象。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <returns>此二进制流文件所对应的可序列化对象</returns>
            <remarks></remarks>
        </member>
        <member name="T:std_ez.TimeHelper">
            <summary>
            与时间数据相关的操作，比如日期与字符、整数之间的相互转换等。
            </summary>
        </member>
        <member name="M:std_ez.TimeHelper.Time2Int(System.DateTime)">
            <summary> 将精确到分钟的时间数据保存为对应的32位整数 </summary>
            <param name="dt">精确度为分钟，更精细的数据将被忽略。
            由于32位数值的限制，能够识别的最大日期为4770年11月24日(23时59分)。即（2^20-1）所对应的日期。</param>
            <returns></returns>
        </member>
        <member name="M:std_ez.TimeHelper.Int2Time(System.Int32)">
            <summary>
            将由 Time2Int 函数生成的整数值再转换回日期数据。返回的最大日期为4770年11月24日(23时59分) ，精度为分钟。
            </summary>
            <param name="intValue">输入的整数值并没有明显的物理含义，
            请确保这个值是通过<see cref="M:std_ez.TimeHelper.Time2Int(System.DateTime)"/>函数生成的。否则给出的结果不可预知，因为其中涉及到复杂的位运算操作。</param>
            <returns>返回的最大日期为4770年11月24日(23时59分) </returns>
        </member>
        <member name="M:std_ez.TimeHelper.String2Date(System.String,System.Nullable{System.DateTime}@)">
            <summary>
            将字符转换为日期。除了.NET能够识别的日期格式外，
            还增加了20160406（ 即 2016/04/06），以及 201604061330（即 2016/04/06 13:30）
            </summary>
            <param name="text">要转换为日期的字符。</param>
            <param name="resultedDate">字符所对应的日期。如果不能转换为日期，则返回Null</param>
            <returns></returns>
        </member>
        <member name="T:std_ez.Utils">
            <summary>
            提供一些基础性的操作工具
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.Utils.ShowEnumerable(System.Collections.IEnumerable,System.String)">
            <summary>
            将集合中的每一个元素的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.Utils.ShowEnumerableP(System.Collections.IEnumerable,System.String,System.String)">
            <summary>
            将集合中的每一个元素的指定属性的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <param name="PropertyName">要读取的属性的名称，注意，此属性不能带参数。</param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.Utils.ShowEnumerableF(System.Collections.IEnumerable,System.String,System.String)">
            <summary>
            将集合中的每一个元素的指定字段的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <param name="FieldName">要读取的字段的名称。</param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.Utils.ShowDebugCatch(System.Exception,System.String,System.String)">
            <summary>
            在调试阶段，为每一种报错显示对应的报错信息及出错位置。
            在软件发布前，应将此方法中的内容修改为常规的报错提醒。
            </summary>
            <param name="ex"> Catch 块中的 Exception 对象</param>
            <param name="message">报错信息提示</param>
            <param name="title"> 报错对话框的标题 </param>
        </member>
        <member name="M:std_ez.Utils.SetDllDirectory(System.String)">
            <summary>
            将指定的文件夹添加到此程序的DLL文件的搜索路径中。
            这个函数只用来在开发时用于AddinManager调试之用，在最终的Release版本中，此函数中的内容可以直接删除。
            </summary>
            <param name="SearchPath">要添加的文件夹路径</param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.Utils.SetDllDirectoryW(System.String)">
            <summary>
            将指定的文件夹添加到此程序的DLL文件的搜索路径中.
            adds a directory to the search path used to locate DLLs for the application.
            </summary>
            <param name="lpPathName">要添加的文件夹路径</param>
            <remarks>Pretty straight-forward to use. Obviously, is usually going to be called before calling LoadLibraryEx().
            另外,在PInvoke中,只有SetDllDirectory这个函数,但是它的真实的名称是SetDllDirectoryW.</remarks>
        </member>
        <member name="M:std_ez.Utils.LoadLibraryEx(System.String,System.IntPtr,std_ez.Utils.LoadLibraryFlags)">
            <summary>
            装载指定的动态链接库，并为当前进程把它映射到地址空间。一旦载入，就可以访问库内保存的资源。一旦不需要，用FreeLibrary函数释放DLL
            </summary>
            <param name="lpFileName">指定要载入的动态链接库的名称。采用与CreateProcess函数的lpCommandLine参数指定的同样的搜索顺序</param>
            <param name="hReservedNull">未用，设为零</param>
            <param name="dwFlags"></param>
            <returns>成功则返回库模块的句柄，零表示失败。会设置GetLastError</returns>
            <remarks>参考 http://www.pinvoke.net/default.aspx/kernel32/LoadLibraryEx.html .
            If you only want to load resources from the library, specify LoadLibraryFlags.LoadLibraryAsDatafile as dwFlags.
            In this case, nothing is done to execute or prepare to execute the mapped file.</remarks>
        </member>
        <member name="T:std_ez.Utils.LoadLibraryFlags">
            <summary>
            用在 LoadLibraryEx 函数中
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:std_ez.Utils.LoadLibraryFlags.DONT_RESOLVE_DLL_REFERENCES">
            <summary> 不对DLL进行初始化，仅用于NT </summary>
        </member>
        <member name="F:std_ez.Utils.LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE">
            <summary> 不准备DLL执行。如装载一个DLL只是为了访问它的资源，就可以改善一部分性能 </summary>
        </member>
        <member name="F:std_ez.Utils.LoadLibraryFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
            <summary> 指定搜索的路径 </summary>
        </member>
        <member name="T:std_ez.WindowsUtil">
            <summary>
            与窗口操作相关的函数，以及鼠标、键盘的操作命令
            </summary>
        </member>
        <member name="M:std_ez.WindowsUtil.keybd_event(System.Byte,System.Byte,System.UInt32,System.UIntPtr)">
             <summary>
             向任意进程发送键盘消息
             </summary>
             <param name="bVk">按键的虚拟键值，如回车键为vk_return, tab键为vk_tab,可以参考常用模拟键的键值对照表，也可以通过System.Windows.Forms.Keys枚举来查看。</param>
             <param name="bScan">扫描码，一般不用设置，用0代替就行；</param>
             <param name="dwFlags">选项标志，如果为keydown则置0即可，如果为keyup则设成数值2，即常数 KEYEVENTF_KEYUP；</param>
             <param name="dwExtraInfo">一般也是置0即可。</param>
             <remarks>
              调用案例1：
             keybd_event(System.Windows.Forms.Keys.Escape, 0, 0, 0)  ' 按下 ESCAPE键
             keybd_event(System.Windows.Forms.Keys.NumLock, 0, KEYEVENTF_KEYUP, 0)  ' 按键弹起，其中 KEYEVENTF_KEYUP=2
              调用案例2：    模拟按下 'ALT+F4'键
             keybd_event(18, 0, 0, 0);
             keybd_event(115, 0, 0, 0);
             keybd_event(115, 0, KEYEVENTF_KEYUP, 0);
             keybd_event(18, 0, KEYEVENTF_KEYUP, 0);
            </remarks>
        </member>
        <member name="T:std_ez.OwnerWindow">
            <summary> 将任意一个窗体作为Form的父窗口，并用在Form.Show(IWin32Window)中 </summary>
        </member>
        <member name="P:std_ez.OwnerWindow.Handle">
            <summary> 父窗口的句柄值 </summary>
        </member>
        <member name="M:std_ez.OwnerWindow.#ctor(System.IntPtr)">
            <summary> 构造函数 </summary>
            <param name="Handle">作为父窗体的窗口句柄值</param>
            <remarks></remarks>
        </member>
        <member name="M:std_ez.OwnerWindow.CreateFromProcessName(System.String)">
            <summary> 通过当前运行的进程名称来获得对应的主窗体 </summary>
            <param name="ProcessName">当前运行的进程名称，此名称可以通过“Windows任务管理器 -> 进程”进行查看。</param>
        </member>
    </members>
</doc>
