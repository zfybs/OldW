<?xml version="1.0"?>
<doc>
    <assembly>
        <name>stdOldW</name>
    </assembly>
    <members>
        <member name="T:stdOldW.DAL.SqlDataSetHelper">
            <summary>
            以数据集DataSet为基础的三层架构的数据库通用方法
            </summary>
        </member>
        <member name="F:stdOldW.DAL.SqlDataSetHelper.ConnectString">
            private static string ConnectString = "server=(local)\\sqlexpress;database=Book;user=sa;pwd=1234";//数据库连接字符串
        </member>
        <member name="M:stdOldW.DAL.SqlDataSetHelper.GetDataSetByTableName(System.String)">
            <summary>
            根据表名获取数据集的表
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.SqlDataSetHelper.GetDataSetBySql(System.String)">
            <summary>
            根据Sql语句获取数据集对象
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.SqlDataSetHelper.GetDataReaderByID(System.Int32)">
            <summary>
            根据id值获取DataReader对象
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.SqlDataSetHelper.UpdateDataTable(System.String)">
            <summary>
            更新数据
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.SqlDataSetHelper.UpdateDataSet(System.Data.DataSet,System.String)">
            <summary>
            根据数据集和sql语句更新数据库
            </summary>
            <param name="ds"></param>
            <param name="sql"></param>
        </member>
        <member name="T:stdOldW.DAL.DataTableHelper">
            <summary>
            与 DataTable 相关的格式转换等操作
            </summary>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.FillDataTable``1(System.Collections.Generic.IList{``0})">
            <summary>
            将实体类中所有的非[Browsable(false)]属性转换成DataTable
            </summary>
            <param name="modelList">实体类集合。如果集合中元素个数为0，则可以成功创建出一个空表格。</param>
            <typeparam name="TEntityClass">数据表所对应的实体类，
            只有实体类中的属性Property才会被创建为数据表中的对应字段，而且此Property不能有[Browsable(false)]标记。</typeparam>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.FillDataTable``1(System.Collections.Generic.IList{``0},System.String[])">
            <summary>
            将实体类中的指定名称的非[Browsable(false)]属性转换成DataTable
            </summary>
            <param name="modelList">实体类集合。如果集合中元素个数为0，则可以成功创建出一个空表格。</param>
            <param name="fieldName">要从实体类中提取成为数据表字段的属性名称（区分大小写）</param>
            <typeparam name="TEntityClass">数据表所对应的实体类，
            只有实体类中的属性Property才会被创建为数据表中的对应字段，而且此Property不能有[Browsable(false)]标记。</typeparam>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.GetPropertiesForTableField``1">
            <summary>
            将指定实体类中的属性进行甄别，以选择出其中可以作为表格字段的属性。
            字段只能对应于属性Property，而且其不能有[Browsable(false)]标记。
            </summary>
            <typeparam name="TEntityClass">数据表所对应的实体类</typeparam>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.GetPropertiesForTableField``1(System.String[])">
            <summary>
            将指定实体类中的指定名称的属性转换为DataTable中的字段对象
            字段只能对应于属性Property，而且其不能有[Browsable(false)]标记。
            </summary>
            <param name="fieldName">要从实体类中提取成为数据表字段的属性名称（区分大小写）</param>
            <typeparam name="TEntityClass">数据表所对应的实体类</typeparam>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.FilterNull(System.Object)">
            <summary> 如果输入的值为null，则返回 DBNull.Value，否则返回这个值本身 </summary>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.GetValue(System.Data.DataTable,System.String)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="table"></param>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.PrintTableOrView(System.Data.DataTable,System.String)">
            <summary>
            将表格打印为格式化的字符
            </summary>
            <param name="table">要打印的表格</param>
            <param name="label">表格的标题</param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.DataTableHelper.PrintTableOrView(System.Data.DataView,System.String)">
            <summary>
            将表格视图打印为格式化的字符
            </summary>
            <param name="table">要打印的表格视图</param>
            <param name="label">视图的标题</param>
            <returns></returns>
        </member>
        <member name="T:stdOldW.DAL.SqlModelHelper">
            <summary>
            以数据实体为基础的三层架构的数据库通用方法
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.ExecuteCommand(System.String)">
            <summary>
            执行无参SQL语句
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.ExecuteCommand(System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            执行带参SQL语句
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.GetScalar(System.String)">
            <summary>
            执行无参SQL语句，并返回执行记录数
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.GetScalar(System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            执行有参SQL语句，并返回执行记录数
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.GetReader(System.String)">
            <summary>
            执行无参SQL语句，并返回SqlDataReader
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.GetReader(System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            执行有参SQL语句，并返回SqlDataReader
            </summary>
        </member>
        <member name="M:stdOldW.DAL.SqlModelHelper.GetDataSet(System.String)">
            <summary>
            执行有参SQL语句，返回DataTable
            </summary>
            <param name="safeSql"></param>
            <returns></returns>
        </member>
        <member name="T:stdOldW.DAL.ExcelDbHelper">
            <summary>
            利用ADO.NET连接Excel数据库，并执行相应的操作：
            创建表格，读取数据，写入数据，获取工作簿中的所有工作表名称。
            </summary>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.ConnectToExcel(System.String,System.Byte)">
            <summary>
            创建对Excel工作簿的连接
            </summary>
            <param name="excelWorkbookPath">要进行连接的Excel工作簿的路径</param>
            <param name="iMEX"> 数据库的连接方式。
            	当 IMEX=0 时为“导出模式Export mode”，这个模式开启的 Excel 档案只能用来做“写入”用途；
             	当 IMEX=1 时为“导入模式Import mode”，这个模式开启的 Excel 档案只能用来做“读取”用途。IMEX=1将前8行的值中有字符类型的字段的数据类型看作字符类型；
            	当 IMEX=2 时为“连结模式Linked mode (full update capabilities)”，这个模式开启的 Excel 档案可同时支持“读取”与“写入”用途。</param>
            <returns>一个OleDataBase的Connection连接，此连接还没有Open。</returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.IsExcelDataSource(System.String)">
            <summary>
            验证连接的数据源是否是Excel数据库
            </summary>
            <param name="excelWorkbookPath"> Excel 工作簿的绝对路径 </param>
            <returns>如果是Excel数据库，则返回True，否则返回False。</returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetSheetsName(System.Data.OleDb.OleDbConnection)">
            <summary>
            从对于Excel的数据连接中获取Excel工作簿中的所有工作表（不包含Excel中的命名区域NamedRange）
            </summary>
            <param name="conn"></param>
            <returns>集合中所有工作表的名称都带有后缀 $ 。如果此连接不是连接到Excel数据库，则返回Nothing</returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetFieldNames(System.Data.OleDb.OleDbConnection,System.String)">
            <summary>
            获取指定工作表中所有字段的名称，包括主键
            </summary>
            <param name="conn"></param>
            <param name="tableName"> 要在哪一个工作表中提取字段信息，表名的格式为“Sheet1$”</param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetFieldDataType(System.Data.OleDb.OleDbConnection,System.String)">
            <summary>
            获取指定工作表中所有字段的数据类型。
            </summary>
            <param name="conn"></param>
            <param name="tableName"> 要在哪一个工作表中提取字段信息，表名的格式为“Sheet1$”</param>
            <remarks>Excel中字段的数据类型是以数字来表示的，其中：时间=7；</remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetDataFromSheet(System.Data.OleDb.OleDbConnection,System.String)">
            <summary>
            读取Excel整张工作表中的所有字段的数据
            </summary>
            <param name="conn">OleDB的数据连接</param>
            <param name="sheetName">要读取的数据所在的工作表，名称中请自行包括后缀$</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetFieldDataFromExcel(System.Data.OleDb.OleDbConnection,System.String,System.String)">
            <summary>
            读取Excel工作表中的某一个字段数据
            </summary>
            <param name="conn">OleDB的数据连接</param>
            <param name="SheetName">要读取的数据所在的工作表，名称中请自行包括后缀$</param>
            <param name="FieldName">在读取的字段</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetFieldDataFromExcel``1(System.Data.OleDb.OleDbConnection,System.String,System.String)">
            <summary>
            读取Excel工作表中的某一个字段数据
            </summary>
            <param name="conn">OleDB的数据连接</param>
            <param name="SheetName">要读取的数据所在的工作表，名称中请自行包括后缀$</param>
            <param name="FieldName">在读取的字段</param>
            <typeparam name="T">要提取的字段的数据类型，比如设置为 double? 等可空类型 </typeparam>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetFieldDataFromExcel(System.Data.OleDb.OleDbConnection,System.String,System.String[])">
            <summary>
            读取Excel工作簿中的多个字段的数据
            </summary>
            <param name="conn">OleDB的数据连接</param>
            <param name="SheetName">要读取的数据所在的工作表，工作表名请自行添加后缀“$”</param>
            <param name="FieldNames">在读取的每一个字段的名称</param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.GetDataSet(System.Data.OleDb.OleDbConnection,System.String)">
            <summary> 执行有参SQL语句，返回DataTable </summary>
            <param name="conn"></param>
            <param name="safeSql">数据查询语句，比如“ Selete * From [Sheet1$] ”</param>
            <returns> DataAdapter.Fill得到的DataSet中的第一个DataTable </returns>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.InsertDataTable(System.Data.OleDb.OleDbConnection,System.Data.DataTable,System.String)">
            <summary>
            将一个全新的 DataTable 对象写入 Excel 数据库中
            </summary>
            <param name="conn"> </param>
            <param name="tableSource"> 数据源，此工作表中的每一个字段中的数据都会被插入到Excel的指定工作表中。
            请手动确保工作表Sheet中有与DataTable中每一列同名的字段，而且其数据类型是兼容的。 </param>
            <param name="sheetName"> 要进行插入的Excel工作表的名称，其格式为“Sheet1$”。请确保此工作表已经存在，而且已经包含与 tableSource 的列名相对应的字段 </param>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.InsertToSheet(System.Data.OleDb.OleDbConnection,System.String,System.String,System.Object)">
            <summary>
            向Excel工作表中插入一条数据
            </summary>
            <param name="conn"></param>
            <param name="sheetName">要插入数据的工作表名称，名称中请自带后缀$ </param>
            <param name="FieldName">要插入到的字段</param>
            <param name="Value">实际插入的数据</param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.CreateNewSheet(System.Data.OleDb.OleDbConnection,System.String,System.String[])">
            <summary>
            根据指定的字段名创建一个全新的Excel工作表，但是不向其中添加任何数据。
            </summary>
            <param name="conn"></param>
            <param name="sheetName"> 要创建的工作表的名称，不能带后缀$ </param>
            <param name="fields_valueTypes"> 工作表中的每一个字段，以及字段所对应的数据类型。如果不赋值，则只创建出一个工作表，而不创建任何字段。 </param>
            <remarks>在Excel中创建工作表的语句为： "CREATE TABLE Sheet1 ( [Field1] VarChar,[Field2] VarChar)" </remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.CreateNewSheet(System.Data.OleDb.OleDbConnection,System.Data.DataTable)">
            <summary>
            根据指定的DataTable 创建一个全新的 Excel 工作表，而不添加任何数据。
            </summary>
            <param name="conn"></param>
            <param name="tableSource"> 工作表名称即 tableSource.TableName；工作表中每一个字段的名称即tableSource中每一列的列名 </param>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.ExecuteNoneQuery(System.Data.OleDb.OleDbConnection,System.String)">
            <summary> 对Excel数据库执行非查询SQL语句 </summary>
            <param name="conn"></param>
            <param name="sql"> 用来执行的非查询sql语句</param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.ConstructFieldNames(System.Collections.Generic.IList{System.String})">
            <summary>
            将要提取的字段名称转换为SQL语句中的字段名称字符
            </summary>
            <param name="FieldNames"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.ConstructDbValue(System.Collections.Generic.IList{System.Object},System.Text.StringBuilder@)">
            <summary>
            将要提取的字段名称转换为SQL语句中的字段名称字符
            </summary>
            <param name="values"></param>
            <param name="sb"></param>
        </member>
        <member name="M:stdOldW.DAL.ExcelDbHelper.ConvertExcelDataType(System.Type)">
            <summary>
            Create Table时，为字段名匹配字段类型
            </summary>
            <param name="type"> .NET 中的数据类型 </param>
            <returns> Excel中的数据类型 </returns>
        </member>
        <member name="T:stdOldW.Tests_Templates.ExeTest">
            <summary> </summary>
        </member>
        <member name="M:stdOldW.Tests_Templates.ExeTest.Main">
            <summary> </summary>
        </member>
        <member name="F:stdOldW.Tests_Templates.Form1.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:stdOldW.Tests_Templates.Form1.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:stdOldW.Tests_Templates.Form1.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:stdOldW.AssemblyCompiler">
            <summary> 动态编译程序集。在程序运行的过程中动态地编译出一个程序集 .dll 或者 .exe。 </summary>
        </member>
        <member name="F:stdOldW.AssemblyCompiler.CodeUnit">
            <summary>
            源代码的架构
            </summary>
        </member>
        <member name="F:stdOldW.AssemblyCompiler.ReferenceDlls">
            <summary>
            要引用的Dll的路径名称，比如"System.dll"
            </summary>
        </member>
        <member name="F:stdOldW.AssemblyCompiler.AssemblyFullName">
            <summary>
            编译生成的Assembly的绝对路径
            </summary>
        </member>
        <member name="F:stdOldW.AssemblyCompiler._compilerResults">
            <summary> 在执行了CompileAssembly方法后所得到的编译结果 </summary>
        </member>
        <member name="P:stdOldW.AssemblyCompiler.CompilerResults">
            <summary> 在执行了CompileAssembly方法后所得到的编译结果 </summary>
        </member>
        <member name="M:stdOldW.AssemblyCompiler.#ctor(System.CodeDom.CodeCompileUnit,System.String[])">
            <summary>
            编译出对应的 CompilerResults 对象，可以通过CompilerResults.CompiledAssembly属性来返回编译成功的Assembly对象。
            </summary>
            <param name="codeUnit">源代码的架构。 codeUnit 对象的创建可以参考<see cref="M:stdOldW.AssemblyCompiler.CompileUnit"/>示例方法。</param>
            <param name="referenceDlls">要引用的Dll的路径名称，比如"System.dll"</param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.AssemblyCompiler.CompileAssembly(System.String)">
            <summary>
            编译出对应的 CompilerResults 对象，可以通过CompilerResults.CompiledAssembly属性来返回编译成功的Assembly对象。
            </summary>
            <param name="dllFileName">最后要编译成的程序集的路径，比如"MyAssembly.dll"或者"MyAssembly.exe"</param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.AssemblyCompiler.CompileUnit">
            <summary>
            示例代码：生成CodeDOM图，这一步是最复杂的部分，后面生成代码与编译都是以这里的东西为蓝本
            </summary>
            <returns> 创建好的 CodeCompileUnit 中，包含了要生成的程序集中的全部代码，
            后面只需要将通过 ICodeGenerator.GenerateCodeFromCompileUnit()方法即可以将这些代码编译为程序集。 </returns>
            <remarks>此函数仅为示例，并不在此类中执行。外部代码可以参数本函数来创建出对应的 CodeCompileUnit 源代码结构 </remarks>
        </member>
        <member name="M:stdOldW.AssemblyCompiler.DeleteAssembly">
            <summary> 删除编译生成的程序集文件 </summary>
        </member>
        <member name="T:stdOldW.Utils">
            <summary>
            提供一些基础性的操作工具
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.Utils.GetNullableGenericArgurment(System.Type)">
            <summary>
            返回Nullable所对应的泛型。如果不是Nullable泛型，则返回null。
            </summary>
            <param name="typeIn"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.Utils.GetTimeFromTimeSpan(System.DateTime,System.Double,stdOldW.UserControls.TimeSpanUnit)">
            <summary> 根据当前指定的时间跨度来对当前时间的增减 </summary>
            <param name="originTime">初始时间</param>
            <param name="spanValue">时间跨度的数值。正值表示增加时间跨度，负值表示送去时间跨度。</param>
            <param name="spanUnit">时间跨度的单位</param>
            <returns></returns>
        </member>
        <member name="T:stdOldW.UserControls.TimeSpanUnit">
            <summary> 时间跨度的单位 </summary>
        </member>
        <member name="T:stdOldW.UserControls.NumberChanging">
            <summary>
            用户控件，用来增加或减少指定的时间跨度值。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.NumberChanging.#ctor">
            <summary> 构造函数 </summary>
        </member>
        <member name="P:stdOldW.UserControls.NumberChanging.ValueNumber">
            <summary> 控件中所对应的数值，即日期文本框上显示的用来进行日期值增减的跨度。
            正值表示增加时间跨度，负值表示送去时间跨度。 </summary>
        </member>
        <member name="P:stdOldW.UserControls.NumberChanging.Unit">
            <summary> 时间跨度的单位 </summary>
        </member>
        <member name="P:stdOldW.UserControls.NumberChanging.IntegerOnly">
            <summary> 是否只允许整数 </summary>
        </member>
        <member name="M:stdOldW.UserControls.NumberChanging.AddTimeSpan(System.DateTime)">
            <summary> 根据当前控件中所对应的时间跨度来进行时间的增减 </summary>
        </member>
        <member name="M:stdOldW.UserControls.NumberChanging.MinusTimeSpan(System.DateTime)">
            <summary> 根据当前控件中所对应的时间跨度来进行时间的增减 </summary>
        </member>
        <member name="M:stdOldW.UserControls.NumberChanging.ModifyTimeSpan(System.DateTime,System.Boolean)">
            <summary> 根据当前控件中所对应的时间跨度来进行时间的增减 </summary>
            <param name="originTime"></param>
            <param name="add">如果为true，则增加时间跨度，如果为false，则减去时间跨度。</param>
            <returns></returns>
        </member>
        <member name="T:stdOldW.UserControls.TextBoxNum">
            <summary> 自定义控件：只能输入数值的文本框。
            当文本框中的数值发生变化时，会触发 ValueNumberChanged 事件，可以通过此事件中的 double 类型的参数来获取最新的数值。
            </summary>
        </member>
        <member name="E:stdOldW.UserControls.TextBoxNum.ValueNumberChanged">
            <summary> double 类型的参数即表示文本框中所代表的最新的数值。 </summary>
        </member>
        <member name="P:stdOldW.UserControls.TextBoxNum.ValueNumber">
            <summary> 文本框中所对应的数值 </summary>
        </member>
        <member name="P:stdOldW.UserControls.TextBoxNum.IntegerOnly">
            <summary> 文本框中是否只允许输入整数 </summary>
        </member>
        <member name="P:stdOldW.UserControls.TextBoxNum.PositiveOnly">
            <summary> 文本框中是否只允许输入正值（包括0） </summary>
        </member>
        <member name="F:stdOldW.UserControls.TextBoxNum._textPattern">
            <summary> 正则表达式的匹配模式 </summary>
        </member>
        <member name="M:stdOldW.UserControls.TextBoxNum.#ctor">
            <summary> 构造函数 </summary>
        </member>
        <member name="M:stdOldW.UserControls.TextBoxNum.ConstructRegexPattern">
            <summary> 根据是否只允许正数或者整数来设置对应的匹配选项 </summary>
        </member>
        <member name="T:stdOldW.UserControls.eZDataGridView">
            <summary>
            自定义控件：DataGridView，向其中增加了：插入行、删除行、显示行号等功能.
            此控件不支持表格内容的复制粘贴，如果要用此功能，请用其派生类<see cref="T:stdOldW.UserControls.eZDataGridViewPaste"/> 
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.myDataGridView_RowsNumberChanged(System.Object,System.Object)">
            <summary>
            行数改变时的事件：显示行号
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.RowsResizable(System.Object,System.Windows.Forms.DataGridViewRowsAddedEventArgs)">
            <summary>
            设置新添加的一行的Resizable属性为False
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.InsertRow(System.Object,System.EventArgs)">
            <summary>
            插入一行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.RemoveOneRow(System.Object,System.EventArgs)">
            <summary>
            移除一行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.RemoveMultipleRows(System.Object,System.EventArgs)">
            <summary>
            移除多行
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridView.myDataGridView_KeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            如下按下 Delete ，则将表格中的选中的单元格中的数据清除 </summary>
        </member>
        <member name="T:stdOldW.UserControls.eZDataGridViewPaste">
            <summary>
            支持复制粘贴功能的表格控件
            </summary>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridViewPaste.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridViewPaste.myDataGridView_KeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
            如下按下Ctrl+V，则将表格中的数据粘贴到DataGridView控件中
            </summary>
            <remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
            DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。</remarks>
        </member>
        <member name="M:stdOldW.UserControls.eZDataGridViewPaste.PasteFromTable(System.Int32,System.Int32)">
            <summary> 将表格中的数据粘贴到DataGridView控件中（通过先添加全部行，再为添加的行赋值的方式） </summary>
            <param name="startRow">粘贴的起始单元格的行位置</param>
            <param name="startCol">粘贴的起始单元格的列位置</param>
            <remarks>DataGridView表格的索引：行号：表头为-1，第一行为0，列号：表示行编号的列为-1，第一个数据列的列号为0.
            DataGridView.Rows.Count与DataGridView.Columns.Count均只计算数据区域，而不包含表头与列头。总行数包括最后一行空数据行。</remarks>
        </member>
        <member name="T:stdOldW.UserControls.LstbxValue`1">
            <summary>
            用来作为ListControl类的.Add方法中的Item参数的类。通过指定ListControl类的DisplayMember属性，来设置列表框中显示的文本。
            </summary>
            <remarks>
            保存数据时：
             With ListBoxWorksheetsName
                  .DisplayMember = LstbxDisplayAndItem.DisplayMember
                  .ValueMember = LstbxDisplayAndItem.ValueMember
                  .DataSource = arrSheetsName   '  Dim arrSheetsName(0 To sheetsCount - 1) As LstbxDisplayAndItem
             End With
            提取数据时：
             Try
                 Me.F_shtMonitorData = DirectCast(Me.ListBoxWorksheetsName.SelectedValue, Worksheet)
             Catch ex As Exception
                 Me.F_shtMonitorData = Nothing
             End Try
            或者是：
             Dim lst As LstbxDisplayAndItem = Me.ComboBoxOpenedWorkbook.SelectedItem
             Try
                Dim Wkbk As Workbook = DirectCast(lst.Value, Workbook)
             Catch ex ...
            </remarks>
            <typeparam name="Tval">Value属性所对应的类型</typeparam>
        </member>
        <member name="F:stdOldW.UserControls.LstbxValue`1.DisplayMember">
            <summary>
            在列表框中进行显示的文本
            </summary>
            <remarks>此常数的值代表此类中代表要在列表框中显示的文本的属性名，即"DisplayedText"</remarks>
        </member>
        <member name="F:stdOldW.UserControls.LstbxValue`1.ValueMember">
            <summary>
            列表框中每一项对应的值（任何类型的值）
            </summary>
            <remarks>此常数的值代表此类中代表列表框中的每一项绑定的数据的属性名，即"Value"</remarks>
        </member>
        <member name="M:stdOldW.UserControls.LstbxValue`1.#ctor(System.String,`0)">
            <summary>
            构造函数
            </summary>
            <param name="DisplayedText">用来显示在列表的UI界面中的文本</param>
            <param name="Value">列表项对应的值</param>
            <remarks></remarks>
        </member>
        <member name="T:stdOldW.UserControls.LstbxValue`1.NothingInListBox">
            <summary>
            列表框中用来表示“什么也没有”。
            1、在声明时：listControl控件.Items.Add(New LstbxDisplayAndItem(" 无", NothingInListBox.None))
            2、在选择列表项时：listControl控件.SelectedValue = NothingInListBox.None
            3、在读取列表中的数据时，作出判断：If Not LstbxItem.Value.Equals(NothingInListBox.None) Then ...
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:stdOldW.UserControls.LstbxValue`1.NothingInListBox.None">
            <summary>
            什么也没有选择
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:stdOldW.WinFormHelper.OwnerWindow">
            <summary> 将任意一个窗体作为Form的父窗口，并用在Form.Show(IWin32Window)中 </summary>
        </member>
        <member name="P:stdOldW.WinFormHelper.OwnerWindow.Handle">
            <summary> 父窗口的句柄值 </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.OwnerWindow.#ctor(System.IntPtr)">
            <summary> 构造函数 </summary>
            <param name="Handle">作为父窗体的窗口句柄值</param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.WinFormHelper.OwnerWindow.CreateFromProcessName(System.String)">
            <summary> 通过当前运行的进程名称来获得对应的主窗体 </summary>
            <param name="ProcessName">当前运行的进程名称，此名称可以通过“Windows任务管理器 -> 进程”进行查看。</param>
        </member>
        <member name="T:stdOldW.WinFormHelper.HideMethodReturnedProc">
            <summary>
            用在 ShowDialogWin 或者 ShowDialogForm 类中。
            当 DialogForm 被隐藏并执行完与Revit交互的hideProc方法后被触发。此事件响应完会即会立即执行  System.Windows.Window.ShowDialog();
            </summary>
            <param name="returnedValue"> hideProc 方法执行完成后的返回值，如果 hideProc 方法没有返回值，则 returnedValue 为 null。</param>
        </member>
        <member name="T:stdOldW.WinFormHelper.IShowDialogThread">
            <summary>
            对于ShowDialog打开的 WinForm 或 WPF window 进行隐藏，并在隐藏后执行相关的界面交互操作。
            </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.IShowDialogThread.HideAndOperate(System.Delegate,stdOldW.WinFormHelper.HideMethodReturnedProc,System.Object[])">
            <summary>
            一个伪异步方法，此方法会在执行Hide之后立即返回。
            </summary>
            <param name="hideProc"> 要与 Revit 进行交互的方法的委托。请在此方法中自行设置异常处理。
            此方法如果有返回值，则通过响应 reternProc 事件来获取返回值。 </param>
            <param name="reternProc"> 当 hideProc 执行完成并得到了返回值后接着执行reternProc方法，请在此方法中自行设置异常处理。
            执行完reternProc后，即会立即执行 Form.ShowDialog(); </param>
            <param name="hideProcArgs"> 方法 hideProc 中的输入参数，如果没有参数，则输入 null </param>
            <remarks>此方法后面不要再有任何的代码语句，如果要处理 hideProc 返回的结果，请在 reternProc 中进行操作。</remarks>
        </member>
        <member name="T:stdOldW.WinFormHelper.ShowDialogForm">
            <summary>
            一个抽象类，用来对以Form.ShowDialog()方法开启的窗口进行操作。
            对于此类的派生类而言，可以通过 <see cref="M:stdOldW.WinFormHelper.ShowDialogForm.HideAndOperate(System.Delegate,stdOldW.WinFormHelper.HideMethodReturnedProc,System.Object[])"/> 方法来将窗口进行隐藏，
            并在隐藏的状态下进行一些常规隐藏窗口下不能进行的操作（比如与 Revit 进行 UI 上的 PickObject() 交互）。
            </summary>
            <remarks> ModelDialog 与 Revit 进行UI交互的原理：在Form打开时，不支持与Revit的UI交互，
            所以，此类通过 HideAndOperate 先将窗口进行隐藏，以跳出当前的ShowDialog的线程阻塞，
            跳出后的线程即返回到 Standard Revit API Context，此时便可以与Revit进行UI交互了。
            在 交互操作 _hideProc 执行完成并通过 _hideMethodReturnedProc 处理完其返回值后，再次通过 Form.ShowDialog() 将窗口显示出来。</remarks>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogForm._hideProc">
            <summary> 在窗口隐藏状态下与 Revit 进行交互 的方法 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogForm._hideProcArgs">
            <summary> _hideProc 方法的输入参数 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogForm.ReturnValue">
            <summary> _hideProc 方法的返回值 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogForm._hideMethodReturnedProc">
            <summary> 在 _hideProc 执行完成后对其返回值进行处理 </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogForm.ShowDialog">
            <summary>
            以 可隐藏的方式显示窗口
            </summary>
            <returns></returns>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogForm.HideAndOperate(System.Delegate,stdOldW.WinFormHelper.HideMethodReturnedProc,System.Object[])">
            <summary>
            一个伪异步方法，此方法会在执行Hide之后立即返回。
            </summary>
            <param name="hideProc"> 要与 Revit 进行交互的方法的委托。请在此方法中自行设置异常处理。
            此方法如果有返回值，则通过响应 reternProc 事件来获取返回值。 </param>
            <param name="reternProc"> 当 hideProc 执行完成并得到了返回值后接着执行reternProc方法，请在此方法中自行设置异常处理。
            执行完reternProc后，即会立即执行 Form.ShowDialog(); </param>
            <param name="hideProcArgs"> 方法 hideProc 中的输入参数，如果没有参数，则输入 null </param>
            <remarks>此方法后面不要再有任何的代码语句，如果要处理 hideProc 返回的结果，请在 reternProc 中进行操作。</remarks>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogFormTemplate.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogFormTemplate.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogFormTemplate.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:stdOldW.WinFormHelper.ShowDialogWin">
            <summary>
            一个抽象类，用来对以Window.ShowDialog()方法开启的窗口进行操作。
            对于此类的派生类而言，可以通过 <see cref="M:stdOldW.WinFormHelper.ShowDialogWin.HideAndOperate(System.Delegate,stdOldW.WinFormHelper.HideMethodReturnedProc,System.Object[])"/> 方法来将窗口进行隐藏，
            并在隐藏的状态下进行一些常规隐藏窗口下不能进行的操作（比如与 Revit 进行 UI 上的 PickObject() 交互）。
            </summary>
            <remarks> ModelDialog 与 Revit 进行UI交互的原理：在Form打开时，不支持与Revit的UI交互，
            所以，此类通过 HideAndOperate 先将窗口进行隐藏，以跳出当前的ShowDialog的线程阻塞，
            跳出后的线程即返回到 Standard Revit API Context，此时便可以与Revit进行UI交互了。
            在 交互操作 _hideProc 执行完成并通过 _hideMethodReturnedProc 处理完其返回值后，再次通过 Window.ShowDialog() 将窗口显示出来。</remarks>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogWin._hideProc">
            <summary> 在窗口隐藏状态下与 Revit 进行交互 的方法 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogWin._hideProcArgs">
            <summary> _hideProc 方法的输入参数 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogWin.ReturnValue">
            <summary> _hideProc 方法的返回值 </summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.ShowDialogWin._hideMethodReturnedProc">
            <summary> 在 _hideProc 执行完成后对其返回值进行处理 </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogWin.ShowDialog">
            <summary>
            以 可隐藏的方式显示窗口
            </summary>
            <returns></returns>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogWin.HideAndOperate(System.Delegate,stdOldW.WinFormHelper.HideMethodReturnedProc,System.Object[])">
            <summary>
            一个伪异步方法，此方法会在执行Hide之后立即返回。
            </summary>
            <param name="hideProc"> 要与 Revit 进行交互的方法的委托。请在此方法中自行设置异常处理。
            此方法如果有返回值，则通过响应 reternProc 事件来获取返回值。 </param>
            <param name="reternProc"> 当 hideProc 执行完成并得到了返回值后接着执行reternProc方法，请在此方法中自行设置异常处理。
            执行完reternProc后，即会立即执行 Window.ShowDialog(); </param>
            <param name="hideProcArgs"> 方法 hideProc 中的输入参数，如果没有参数，则输入 null </param>
            <remarks>此方法后面不要再有任何的代码语句，如果要处理 hideProc 返回的结果，请在 reternProc 中进行操作。</remarks>
        </member>
        <member name="T:stdOldW.WinFormHelper.ShowDialogWinTemplate">
            <summary>
            Interaction logic for MainWindow.xaml
            </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.ShowDialogWinTemplate.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:stdOldW.WinFormHelper.WindowsUtil">
            <summary>
            与窗口操作相关的函数，以及鼠标、键盘的操作命令
            </summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.WindowsUtil.keybd_event(System.Byte,System.Byte,System.UInt32,System.UIntPtr)">
             <summary>
             向任意进程发送键盘消息
             </summary>
             <param name="bVk">按键的虚拟键值，如回车键为vk_return, tab键为vk_tab,可以参考常用模拟键的键值对照表，也可以通过System.Windows.Forms.Keys枚举来查看。</param>
             <param name="bScan">扫描码，一般不用设置，用0代替就行；</param>
             <param name="dwFlags">选项标志，如果为keydown则置0即可，如果为keyup则设成数值2，即常数 KEYEVENTF_KEYUP；</param>
             <param name="dwExtraInfo">一般也是置0即可。</param>
             <remarks>
              调用案例1：
             keybd_event(System.Windows.Forms.Keys.Escape, 0, 0, 0)  ' 按下 ESCAPE键
             keybd_event(System.Windows.Forms.Keys.NumLock, 0, KEYEVENTF_KEYUP, 0)  ' 按键弹起，其中 KEYEVENTF_KEYUP=2
              调用案例2：    模拟按下 'ALT+F4'键
             keybd_event(18, 0, 0, 0);
             keybd_event(115, 0, 0, 0);
             keybd_event(115, 0, KEYEVENTF_KEYUP, 0);
             keybd_event(18, 0, KEYEVENTF_KEYUP, 0);
            </remarks>
        </member>
        <member name="M:stdOldW.WinFormHelper.WindowsUtil.mouse_event(stdOldW.WinFormHelper.WindowsUtil.MouseOperation,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary> 发送鼠标消息 </summary>
            <param name="dwFlags"> (位编码)要如何操作鼠标。如果不指定 MOUSEEVENTF_ABSOLUTE，则是相对于当前的鼠标位置。 </param>
            <param name="dx">根据MOUSEEVENTF_ABSOLUTE标志，指定x，y方向的绝对位置或相对位置 </param>
            <param name="dy">根据MOUSEEVENTF_ABSOLUTE标志，指定x，y方向的绝对位置或相对位置 </param>
            <param name="dwData">没有使用，直接赋值为0 </param>
            <param name="dwExtraInfo">没有使用，直接赋值为0 </param>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_Move">
            <Summary> 移动鼠标 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_LeftDown">
            <Summary> 模拟鼠标左键按下 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_LeftUp">
            <Summary> 模拟鼠标左键抬起 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_RightDown">
            <Summary> 模拟鼠标右键按下 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_RightUp">
            <Summary> 模拟鼠标右键抬起 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_MiddleDown">
            <Summary> 模拟鼠标中键按下 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_MiddleUp">
            <Summary> 模拟鼠标中键抬起 </Summary>
        </member>
        <member name="F:stdOldW.WinFormHelper.WindowsUtil.MouseOperation.MouseEventF_Absolute">
            <Summary> 标示是否采用绝对坐标 </Summary>
        </member>
        <member name="M:stdOldW.WinFormHelper.WindowsUtil.ChooseOpenExcel(System.String)">
            <summary> 通过选择文件对话框选择要进行数据提取的Excel文件 </summary>
            <returns> 要进行数据提取的Excel文件的绝对路径 </returns>
        </member>
        <member name="M:stdOldW.WinFormHelper.WindowsUtil.ChooseSaveExcel(System.String)">
            <summary> 通过选择文件对话框选择要进行数据写入的Excel文件 </summary>
            <returns> 要进行数据写入的Excel文件的绝对路径 </returns>
        </member>
        <member name="M:stdOldW.ExtensionMethods.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            将某集合中的元素添加到另一个集合中去
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="items"></param>
        </member>
        <member name="M:stdOldW.ExtensionMethods.Clone``1(``0)">
            <summary>
            Strong-typed object cloning for objects that implement <see cref="T:System.ICloneable"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.ExtensionMethods.IndexOf``2(``0,``1)">
            <summary>
            从集合中搜索指定项的下标位置（第一个元素的下标值为0），如果没有匹配项，则返回-1。
            </summary>
            <typeparam name="TCol"></typeparam>
            <param name="collection"> 匹配的数据源集合 </param>
            <typeparam name="TVal"></typeparam>
            <param name="value"> 要进行匹配的值 </param>
            <returns> 从集合中搜索指定项的下标位置（第一个元素的下标值为0），如果没有匹配项，则返回-1。 </returns>
        </member>
        <member name="T:stdOldW.StringSerializer">
            <summary>
            将任意一个有 Serializable标记的类以二进制转换器将类中所有数据与字符串间的相互序列化。
            即可以将类中的数据（包括数组）序列化为字符，还可以将序列化的字符反序列化为一个类。
            </summary>
        </member>
        <member name="M:stdOldW.StringSerializer.Encode64(System.Object)">
            <summary>
            Encode arbitrary .NET serialisable object
            into binary data encodes as base64 string.
            </summary>
        </member>
        <member name="M:stdOldW.StringSerializer.Decode64(System.String)">
            <summary>
            Decode arbitrary .NET serialisable object
            from binary data encoded as base64 string.
            </summary>
        </member>
        <member name="T:stdOldW.StringSerializer.ZengfyLinkBinder">
            <summary>
            为了解决SerializationException，方法之一是确保此assembly放置在与acad.exe 或 revit.exe相同的文件夹中，
            另一个方法就是实现一个像这样的类。
            </summary>
            <remarks>
             Resolve System.Runtime.Serialization.SerializationException, Message =
            "Unable to find assembly 'StoreData, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'."
            One solution is to ensure that assembly resides in same directory as acad.exe or revit.exe,
            the other is to implement a class such as this, cf.
            http://www.codeproject.com/soap/Serialization_Samples.asp
            </remarks>
        </member>
        <member name="T:stdOldW.BinarySerializer">
            <summary>
            在.NET中，我们可以将对象序列化从而保存对象的状态到内存或者磁盘文件中，或者分布式应用程序中用于系统通信，，这样就有可能做出一个“对象数据库”了。
            一般来说，二进制序列化的效率要高，所获得的字节数最小。
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.BinarySerializer.EnCode(System.IO.Stream,System.Object)">
            <summary>
            将任意一个声明为Serializable的类或者其List等集合中的数据，以二进制的格式保存到对应的流文件中。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <param name="Data">要进行保存的可序列化对象</param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.BinarySerializer.DeCode(System.IO.Stream)">
            <summary>
            从二进制流文件中，将其中的二进制数据反序列化为对应的类或集合对象。
            </summary>
            <param name="fs">推荐使用FileStream对象。此方法中不会对Stream对象进行Close。</param>
            <returns>此二进制流文件所对应的可序列化对象</returns>
            <remarks></remarks>
        </member>
        <member name="T:stdOldW.DateTimeHelper">
            <summary>
            与时间数据相关的操作，比如日期与字符、整数之间的相互转换等。
            </summary>
        </member>
        <member name="M:stdOldW.DateTimeHelper.Time2Int(System.DateTime)">
            <summary> 将精确到分钟的时间数据保存为对应的32位整数 </summary>
            <param name="dt">精确度为分钟，更精细的数据将被忽略。
            由于32位数值的限制，能够识别的最大日期为4770年11月24日(23时59分)。即（2^20-1）所对应的日期。</param>
            <returns></returns>
        </member>
        <member name="M:stdOldW.DateTimeHelper.Int2Time(System.Int32)">
            <summary>
            将由 Time2Int 函数生成的整数值再转换回日期数据。返回的最大日期为4770年11月24日(23时59分) ，精度为分钟。
            </summary>
            <param name="intValue">输入的整数值并没有明显的物理含义，
            请确保这个值是通过<see cref="M:stdOldW.DateTimeHelper.Time2Int(System.DateTime)"/>函数生成的。否则给出的结果不可预知，因为其中涉及到复杂的位运算操作。</param>
            <returns>返回的最大日期为4770年11月24日(23时59分) </returns>
        </member>
        <member name="M:stdOldW.DateTimeHelper.String2Date(System.String)">
            <summary>
            将字符转换为日期。除了.NET能够识别的日期格式外，
            还增加了20160406（ 即 2016/04/06），以及 201604061330（即 2016/04/06 13:30）
            </summary>
            <param name="text">要转换为日期的字符。</param>
            <returns> 字符所对应的日期。如果不能转换为日期，则返回Null</returns>
        </member>
        <member name="T:stdOldW.DebugUtils">
            <summary>
            提供一些基础性的操作工具
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DebugUtils.ShowEnumerable(System.Collections.IEnumerable,System.String,System.Boolean)">
            <summary>
            将集合中的每一个元素的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <param name="title"></param>
            <param name="newLineHandling"> 如果元素之间是以换行分隔，则为True，否则是以逗号分隔。 </param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DebugUtils.ShowEnumerableProperty(System.Collections.IEnumerable,System.String,System.String,System.Boolean)">
            <summary>
            将集合中的每一个元素的指定属性的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <param name="PropertyName">要读取的属性的名称，注意，此属性不能带参数。</param>
            <param name="newLineHandling"> 如果元素之间是以换行分隔，则为True，否则是以逗号分隔。 </param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DebugUtils.ShowEnumerableField(System.Collections.IEnumerable,System.String,System.String,System.Boolean)">
            <summary>
            将集合中的每一个元素的指定字段的ToString函数的结果组合到一个字符串中进行显示
            </summary>
            <param name="V"></param>
            <param name="FieldName">要读取的字段的名称。</param>
            <param name="newLineHandling"> 如果元素之间是以换行分隔，则为True，否则是以逗号分隔。 </param>
            <remarks></remarks>
        </member>
        <member name="M:stdOldW.DebugUtils.ShowDebugCatch(System.Exception,System.String,System.String)">
            <summary>
            在调试阶段，为每一种报错显示对应的报错信息及出错位置。
            在软件发布前，应将此方法中的内容修改为常规的报错提醒。
            </summary>
            <param name="ex"> Catch 块中的 Exception 对象</param>
            <param name="message">报错信息提示</param>
            <param name="title"> 报错对话框的标题 </param>
        </member>
        <member name="T:OldW.DllActivator.IDllActivator">
            <summary>
            用于在IExternalCommand.Execute方法中，将整个项目的所有dll加载到进程中。
            以避免出现在后面出现无法加载文件或者程序集的问题。
            此接口是专门为AddinManager在调试时设计的，在最终软件发布之前，此接口以及所有与之相关的类以及调用方法都可以删除。
            </summary>
            <remarks>在每一次调用Execute方法的开关，都可以用如下代码来将对应项目的所有引用激活。
            DllActivator.DllActivator_Projects dat = new DllActivator.DllActivator_Projects();
            dat.ActivateReferences();
            </remarks>
        </member>
        <member name="M:OldW.DllActivator.IDllActivator.ActivateReferences">
            <summary> 激活本DLL所引用的那些DLLs </summary>
        </member>
        <member name="T:OldW.DllActivator.DllActivator_std">
            <summary> </summary>
        </member>
        <member name="M:OldW.DllActivator.DllActivator_std.ActivateReferences">
            <summary>
            激活本DLL所引用的那些DLLs
            </summary>
        </member>
    </members>
</doc>
